
/*
	字符串
		KMP算法


		两种模式匹配算法

			字符串模式匹配
				朴素模式匹配算法
				KMP算法


		KMP算法
			由D.E.Knuth，J.H.Morris和V.R.Pratt提出，因此称为 KMP算法


		朴素模式匹配算法
			主串长度n，模式串长度m。将主串中所有长度为m的子串与模式串对比，找到第一个模式串匹配的子串

		朴素模式匹配算法优化思路(KMP算法)
			|           i
			|           ↓
			|   主串S  [a][b][a][a][b][?][?][?][?][?][?][?][?][?][?]
			|           1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
			|                                      1  1  1  1  1  1
			|
			|            j
			|            ↓
			|   模式串T [a][b][a][a][b][c]
			|            1  2  3  4  5  6

			(该结论对模式串"abaabc"具有通用性，和主串没有半毛钱关系)
			                          ↓               ↓
			对于模式串 T="abaabc"，当 第6个元素匹配失败时，可令 主串指针i不变，模式串指针j=3。

			对于模式串 T="abaabc"，当 第5个元素匹配失败时，可令 主串指针i不变，模式串指针j=2。

			对于模式串 T="abaabc"，当 第4个元素匹配失败时，可令 主串指针i不变，模式串指针j=2。

			对于模式串 T="abaabc"，当 第3个元素匹配失败时，可令 主串指针i不变，模式串指针j=1。

			对于模式串 T="abaabc"，当 第2个元素匹配失败时，可令 主串指针i不变，模式串指针j=1。

			对于模式串 T="abaabc"，当 第1个元素匹配失败时，匹配下一个相邻子串，可令 j=0,i++,j++。


			怎么用代码实现这个处理逻辑？

				next数组
					|   next[0] next[1] next[2] next[3] next[4] next[5] next[6]
					|                0       1       1       2       2       3

					当某一个位置匹配失败时，应该把 j 的值修改为多少

					转换成代码
						if(S[i] != T[j])
						{
							j = next[j];
						}
						if(j == 0)
						{
							i++;
							j++;
						}

					next数组只和短短的模式串有关，和长长的主串无关

				KMP算法整体流程
					根据 模式串T，求出 next数组
					↓
					利用 next数组 进行匹配(主串指针不回溯)

					int Index_KMP(SString S, SString T, int next[])
					{
						int i = 1;
						int j = 1;

						while (i <= S.length && j <= T.length)
						{
							if (j == 0 || S.ch[i] == T.ch[j])
							{
								// 继续比较后继字符
								++i;
								++j;
							}
							else
							{
								// 模式串向右移动
								j = next[j];
							}
						}

						if (j > T.length)
						{
							// 匹配成功
							return i - T.length;
						}
						else
						{
							return 0;
						}
					}


				朴素模式匹配算法，最坏时间复杂度 O(mn)
				KMP算法，        最坏时间复杂度 O(m+n)，其中，求next数组时间复杂度 O(m)，模式匹配过程最坏时间复杂度 O(n)

下一章 王道_37-4.2_3_求next数组
*/
