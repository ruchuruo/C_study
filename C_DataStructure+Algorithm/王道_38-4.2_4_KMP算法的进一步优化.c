
/*
	KMP算法
		进一步优化


		next数组的优化思路
			|      i
			|      ↓
			|                                 1  1  1  1  1  1
			|      1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
			|   S [?][?][?][?][?][?][?][?][?][?][?][?][?][?][?]
			|
			|   T [a][b][a][a][b][c]
			|      1  2  3  4  5  6
			|      ↑
			|      j
			|
			|   next [ ][0][1][1][2][2][3]
			|            1  2  3  4  5  6

			假设 模式串T 第三个字符a匹配失败，利用next数组，j = 1，从模式串的第一个字符开始往后匹配，
			但是现在模式串的第一个字符也是a，所以下一次匹配也会失败。这里完全可以让j = 0。
			最好的处理方式是直接让next[3]等于0
				|   next [ ][0][1][0][2][2][3]
				|            1  2  3  4  5  6

			假设 模式串T 第五个字符b匹配失败，利用next数组，j = 2，从模式串的第二个字符开始往后匹配，
			但是现在模式串的第一个字符也是b，所以下一次匹配也会失败。因为2位置的字符和5位置的字符相同。
			最好的处理方式是直接让next[5]等于1
				|   next [ ][0][1][0][2][1][3]
				|            1  2  3  4  5  6

			next数组中不是所有的值都能优化，要判断next数组它所指的这个字符和原本 不匹配 的字符，是否相等，
			不相等 数组值保持不变；如果next数组所指向的新位置，和当前匹配失败的这个位置相同，那就可以优化
				|-----------------------------
				|   可以优化
				|      +-----+
				|      ↓     ↓
				|   T [a][b][a][a][b][c]
				|      1  2  3  4  5  6
				|
				|                  ↓
				|   next [ ][0][1][1][2][2][3]
				|            1  2  3  4  5  6
				|-----------------------------
				|   不能优化
				|            +--------+
				|            ↓        ↓
				|   T [a][b][a][a][b][c]
				|      1  2  3  4  5  6
				|
				|                           ↓
				|   next [ ][0][1][1][2][2][3]
				|            1  2  3  4  5  6

			用刚才的思路可以讲 next数组 优化成 nextval数组，之后kmp算法匹配的时候用 nextval数组 替代 next数组 就可以了


		求nextval数组

			nextval[1] = 0;// 1号位置无脑写0
			for(int j = 2; j <= T.length; j++)
			{
				if(T.ch[next[j]] == T.ch[j])
				{
					nextval[j] = nextval[next[j]];
				}
				else
				{
					nextval[j] = next[j];
				}
			}

*/