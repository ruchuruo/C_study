/*
	自定义类型：结构体，枚举，联合

		本章重点
		
			● 结构体
				○ 结构体类型的声明
				○ 结构的自引用
				○ 结构体变量的定义和初始化
				○ 结构体内存对齐
				○ 结构体传参
				○ 结构体实现位段(位段的填充&可移植性)

			● 枚举
				○ 枚举类型的定义
				○ 枚举的优点
				○ 枚举的使用

			● 联合
				○ 联合类型的定义
				○ 联合的特点
				○ 联合大小的计算

		――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

		● 结构体

			○ 结构体类型的声明

				结构的基础知识
					结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。

					结构是用来定义一个复杂对象的

					复杂类型
						生活中有一些对象是复杂的，
						比如
							书：书名，作者，出版社，定价，书号......
							学生：名字，年龄，电话，学号......

				结构的声明
					struct tag
					{
						member-list;
					}variable-list;

					struct			关键字
					tag				结构体标签名
					struct tag		结构体类型名
					member-list		成员变量的列表
					variable-list	变量列表

					讲解在
						结构体类型的声明_结构的声明();

				特殊的声明
					在声明结构的时候，可以不完全的声明
					匿名结构体类型创建好后只能使用一次，创建不了变量，因为没有结构体标签名

					讲解在
						结构体类型的声明_特殊的声明();


			○ 结构的自引用

				在结构中包含一个类型为该结构本身的成员是否可以？

				讲解在
					结构的自引用();


			○ 结构体变量的定义和初始化

				讲解在
					结构体变量的定义和初始化();


			○ 结构体内存对齐
				现在我们深入讨论一个问题：计算结构体的大小
				这也是一个特别热门的考点：结构体内存对齐

				讲解在
					结构体内存对齐();
*/
/*――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――*/
/*
	数据结构
		数据在内存中存储的结构

		假设存储数据1 2 3 4 5

		线性数据结构
			顺序表：
				[1][2][3][4][5]
				--------------→

			链表：
				[1]
				  K
					K			  [3]
					  K			 J|
						K	   J  |
						  K J	   |
						   [2]	   |
								   ↓
					[5]←----------[4]

				链表里存1的东西叫做 节点，多个节点要串起来，节点该如何设计？
				节点前面存数据，后面存下一个节点的地址，最后一个节点后面存空指针
				节点分成两部分：[ 数据域 | 指针域 ]

		树形
			二叉树
*/
/*――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――*/

#include "define.h"

void n(int y)
{
	if (y < 0)
	{
		y = y * (-1);
		printf("\n-------- -------- -------- --------");
		int i = 0;
		for (i = 0; i < y; i++)
		{
			printf("\n");
		}
	}
	else
	{
		int i = 0;
		for (i = 0; i < y; i++)
		{
			printf("\n");
		}
	}
}

/**************************************************************************************************************************************************/
/*================================================================================================================================================*/

void 结构体类型的声明_结构的声明()
{
	printf("结构体类型的声明_结构的声明\n");

	struct 书
	{
		char 书名[20];
		int 定价;
		char 书号[12];
	}b4, b5, b6;// 用结构体类型创建变量

	struct 书 b1;// 用结构体类型创建变量
	struct 书 b2;
	struct 书 b3;

	n(1);
}

/*================================================================================================================================================*/

void 结构体类型的声明_特殊的声明()
{
	printf("结构体类型的声明_特殊的声明\n");

	// 匿名结构体类型
	struct 
	{
		int a;
		char b;
		float c;
	}x;

	// 匿名结构体类型
	struct
	{
		int a;
		char b;
		float c;
	}*ps;	// * 匿名结构体类型的指针
			// 用这个指针类型创建了变量ps

	ps = &x;// 在编译器看来，虽然成员一样，但是类型不一样
			// 如果类型不相同，这个结构体的指针里就不能存放x变量的地址
			// 从“*”到“*”的类型不兼容
			// 编译器会把上面的两个声明当成完全不同的两个类型，所以是非法的

	n(1);
}

/*================================================================================================================================================*/

void 结构的自引用()
{
	printf("结构的自引用\n");

	// 行
	struct A
	{
		int i;
		char c;
	};

	// 行
	struct B
	{
		char c;
		struct A sa;
		double d;
	};

	// 这样不行，自己不能包含自己，会套娃，大小无限
	//struct N
	//{
	//	int d;
	//	struct N n;
	//};

	// 结构的自引用，不是包含同类型结构体的变量，而是包含同类型结构体的指针
	struct 节点
	{
		int 数据;
		struct 节点* 下一个;// 为什么是struct 节点*？因为存的下一个节点，类型和它一样。
						   // 如果是指针变量，那大小就是可算的，4或8字节
	};

	n(1);
}

/*================================================================================================================================================*/

void 结构体变量的定义和初始化()
{
	printf("结构体变量的定义和初始化\n");

	struct S
	{
		char c;
		int i;
	}s1, s2;// 声明类型的同时定义变量s1，s2

	struct B
	{
		double d;
		struct S s;
		char c;
	};

	struct S s3, s4;// 定义结构体变量s3，s4
	struct S s5 = { 'x',20 };// 初始化，定义变量的同时赋初值
	struct B b1 = { 3.14,{ 'x',20 } ,'q' };// 结构体包含结构体初始化

	printf("%lf %c %d %c\n", b1.d, b1.s.c, b1.s.i, b1.c);//操作符 . 和 -> ，.针对结构体变量 ->针对结构体指针

	n(1);
}

/*================================================================================================================================================*/

void 结构体内存对齐()
{
	printf("结构体内存对齐\n");

	struct S
	{
		int i;
		char c;
	};

	struct S2
	{
		char c1;
		int i;
		char c2;
	};

	struct S s = { 0 };// 不完全初始化，其余默认初始化为0
	struct S2 s2 = { 0 };

	// 大小不一样，涉及到结构体内存对齐
	printf("%d\n", sizeof(s));
	printf("%d\n", sizeof(s2));

	n(-2);
}

/*================================================================================================================================================*/

int main()
{
	结构体类型的声明_结构的声明();

	结构体类型的声明_特殊的声明();

	结构的自引用();

	结构体变量的定义和初始化();

	结构体内存对齐();

	return 0;
}

/**************************************************************************************************************************************************/
