/*
	自定义类型：结构体，枚举，联合

		本章重点
		
			● 结构体
				○ 结构体类型的声明
				○ 结构的自引用
				○ 结构体变量的定义和初始化
				○ 结构体内存对齐
				○ 结构体传参
				○ 结构体实现位段(位段的填充&可移植性)

			● 枚举
				○ 枚举类型的定义
				○ 枚举的优点
				○ 枚举的使用

			● 联合
				○ 联合类型的定义
				○ 联合的特点
				○ 联合大小的计算

		――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

		● 结构体

			○ 结构体类型的声明

				结构的基础知识
					结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。

					结构是用来定义一个复杂对象的

					复杂类型
						生活中有一些对象是复杂的，
						比如
							书：书名，作者，出版社，定价，书号......
							学生：名字，年龄，电话，学号......

				结构的声明
					struct tag
					{
						member-list;
					}variable-list;

					struct			关键字
					tag				结构体标签名
					struct tag		结构体类型名
					member-list		成员变量的列表
					variable-list	变量列表

					讲解在
						结构体类型的声明_结构的声明();

				特殊的声明
					在声明结构的时候，可以不完全的声明
					匿名结构体类型创建好后只能使用一次，创建不了变量，因为没有结构体标签名

					讲解在
						结构体类型的声明_特殊的声明();


			○ 结构的自引用

				在结构中包含一个类型为该结构本身的成员是否可以？

				讲解在
					结构的自引用();


			○ 结构体变量的定义和初始化

				讲解在
					结构体变量的定义和初始化();


			○ 结构体内存对齐
				现在我们深入讨论一个问题：计算结构体的大小
				这也是一个特别热门的考点：结构体内存对齐

				结构体的对齐规则
					1. 第一个成员在与结构体变量偏移量为0的地址处
					2. 其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处
					3. 结构体总大小为最大对齐数(每个成员变量都有一个对齐数)的整数倍
					4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，
					   结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍

					对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值

					VS中默认的值为8
					Linux没有默认对齐数的概念

							-----
							|   |
							-----
							|   |
							-----
							|   |
							----- ← 变量s从这开辟空间，并且向下走↓，总共占了12字节
					偏移量0	|   | 成员 char c1
							-----
					偏移量1	|   | (浪费的)
							-----
					偏移量2	|   | (浪费的)
							-----
					偏移量3	|   | (浪费的)
							-----
					偏移量4	|   | 成员 int i
							-----
					偏移量5	|   | 成员 int i
							-----
					偏移量6	|   | 成员 int i
							-----
					偏移量7	|   | 成员 int i
							-----
					偏移量8	|   | 成员 char c2
							-----
							|   | (浪费的)
							-----
							|   | (浪费的)
							-----
							|   | (浪费的)
							-----
							|   |
							-----
					
				为什么存在内存对齐？
					大部分的参考资料都是如是说：

						1. 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；
							某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

						2. 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。
							原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

					总体来说：
						结构体的内存对齐是拿 空间 来换取 时间 的做法。

				讲解在
					结构体内存对齐();
					结构体内存对齐II();
*/
/*――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――*/
/*
	数据结构
		数据在内存中存储的结构

		假设存储数据1 2 3 4 5

		线性数据结构
			顺序表：
				[1][2][3][4][5]
				--------------→

			链表：
				[1]
				  K
					K			  [3]
					  K			 J|
						K	   J  |
						  K J	   |
						   [2]	   |
								   ↓
					[5]←----------[4]

				链表里存1的东西叫做 节点，多个节点要串起来，节点该如何设计？
				节点前面存数据，后面存下一个节点的地址，最后一个节点后面存空指针
				节点分成两部分：[ 数据域 | 指针域 ]

		树形
			二叉树
*/
/*――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――*/

#include "define.h"

void n(int y)
{
	if (y < 0)
	{
		y = y * (-1);
		printf("\n-------- -------- -------- --------");
		int i = 0;
		for (i = 0; i < y; i++)
		{
			printf("\n");
		}
	}
	else
	{
		int i = 0;
		for (i = 0; i < y; i++)
		{
			printf("\n");
		}
	}
}

/**************************************************************************************************************************************************/
/*================================================================================================================================================*/

void 结构体类型的声明_结构的声明()
{
	printf("结构体类型的声明_结构的声明\n");

	struct 书
	{
		char 书名[20];
		int 定价;
		char 书号[12];
	}b4, b5, b6;// 用结构体类型创建变量

	struct 书 b1;// 用结构体类型创建变量
	struct 书 b2;
	struct 书 b3;

	n(1);
}

/*================================================================================================================================================*/

void 结构体类型的声明_特殊的声明()
{
	printf("结构体类型的声明_特殊的声明\n");

	// 匿名结构体类型
	struct 
	{
		int a;
		char b;
		float c;
	}x;

	// 匿名结构体类型
	struct
	{
		int a;
		char b;
		float c;
	}*ps;	// * 匿名结构体类型的指针
			// 用这个指针类型创建了变量ps

	ps = &x;// 在编译器看来，虽然成员一样，但是类型不一样
			// 如果类型不相同，这个结构体的指针里就不能存放x变量的地址
			// 从“*”到“*”的类型不兼容
			// 编译器会把上面的两个声明当成完全不同的两个类型，所以是非法的

	n(1);
}

/*================================================================================================================================================*/

void 结构的自引用()
{
	printf("结构的自引用\n");

	// 行
	struct A
	{
		int i;
		char c;
	};

	// 行
	struct B
	{
		char c;
		struct A sa;
		double d;
	};

	// 这样不行，自己不能包含自己，会套娃，大小无限
	//struct N
	//{
	//	int d;
	//	struct N n;
	//};

	// 结构的自引用，不是包含同类型结构体的变量，而是包含同类型结构体的指针
	struct 节点
	{
		int 数据;
		struct 节点* 下一个;// 为什么是struct 节点*？因为存的下一个节点，类型和它一样。
						   // 如果是指针变量，那大小就是可算的，4或8字节
	};

	n(1);
}

/*================================================================================================================================================*/

void 结构体变量的定义和初始化()
{
	printf("结构体变量的定义和初始化\n");

	struct S
	{
		char c;
		int i;
	}s1, s2;// 声明类型的同时定义变量s1，s2

	struct B
	{
		double d;
		struct S s;
		char c;
	};

	struct S s3, s4;// 定义结构体变量s3，s4
	struct S s5 = { 'x',20 };// 初始化，定义变量的同时赋初值
	struct B b1 = { 3.14,{ 'x',20 } ,'q' };// 结构体包含结构体初始化

	printf("%lf %c %d %c\n", b1.d, b1.s.c, b1.s.i, b1.c);//操作符 . 和 -> ，.针对结构体变量 ->针对结构体指针

	n(1);
}

/*================================================================================================================================================*/

void 结构体内存对齐()
{
	printf("结构体内存对齐\n");

	struct S
	{
		int i;
		char c;
	};

	struct S2
	{
		char c1;
		int i;
		char c2;
	};

	struct S s = { 0 };// 不完全初始化，其余默认初始化为0
	struct S2 s2 = { 0 };

	// 大小不一样，涉及到结构体内存对齐
	printf("%d\n", sizeof(s));
	printf("%d\n", sizeof(s2));

	n(1);
}

/*------------------------------------------------------------------------------------------------------------------------------------------------*/

void 结构体内存对齐II()
{
	printf("结构体内存对齐II\n");

	struct S
	{
		char c1;
		int i;
		char c2;
	};

	struct S4
	{
		double d;
		char c;
		int i;
	};

	struct S5
	{
		char c1;
		struct S4 s4; // s4 占16字节，要如何放？
		double d;
	};

	struct S s = { 0 };
	struct S5 s5 = { 0 };

	printf("%d\n", sizeof(s));
	printf("%d\n", sizeof(s5));			// 32
	printf("%d\n", sizeof(struct S5));	// 32

	/*
		4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，
		   结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍

			偏移量	空间		说明
					-----
					|   |
					----- ← 变量s5从这开辟空间，并且向下走↓，总共占了32字节
				0	|   | 成员 char c1
					-----
				1	|   | (浪费的)
					-----
				2	|   | (浪费的)
					-----
				3	|   | (浪费的)
					-----
				4	|   | (浪费的)
					-----
				5	|   | (浪费的)
					-----
				6	|   | (浪费的)
					-----
				7	|   | (浪费的)
					-----
				8	|   | 成员 struct S4 s4 成员 double d
					-----
				9	|   | 成员 struct S4 s4 成员 double d
					-----
				10	|   | 成员 struct S4 s4 成员 double d
					-----
				11	|   | 成员 struct S4 s4 成员 double d
					-----
				12	|   | 成员 struct S4 s4 成员 double d
					-----
				13	|   | 成员 struct S4 s4 成员 double d
					-----
				14	|   | 成员 struct S4 s4 成员 double d
					-----
				15	|   | 成员 struct S4 s4 成员 double d
					-----
				16	|   | 成员 struct S4 s4 成员 char c
					-----
				17	|   | 成员 struct S4 s4 (浪费的)
					-----
				18	|   | 成员 struct S4 s4 (浪费的)
					-----
				19	|   | 成员 struct S4 s4 (浪费的)
					-----
				20	|   | 成员 struct S4 s4 成员 int i
					-----
				21	|   | 成员 struct S4 s4 成员 int i
					-----
				22	|   | 成员 struct S4 s4 成员 int i
					-----
				23	|   | 成员 struct S4 s4 成员 int i
					-----
				24	|   | 成员 double d
					-----
				25	|   | 成员 double d
					-----
				26	|   | 成员 double d
					-----
				27	|   | 成员 double d
					-----
				28	|   | 成员 double d
					-----
				29	|   | 成员 double d
					-----
				30	|   | 成员 double d
					-----
				31	|   | 成员 double d
					-----
	*/

	n(-2);
}

/*================================================================================================================================================*/

int main()
{
	结构体类型的声明_结构的声明();

	结构体类型的声明_特殊的声明();

	结构的自引用();

	结构体变量的定义和初始化();

	结构体内存对齐();
	结构体内存对齐II();

	return 0;
}

/**************************************************************************************************************************************************/
