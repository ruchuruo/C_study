/*
	自定义类型：结构体，枚举，联合

		本章重点
		
			● 结构体
				○ 结构体类型的声明
				○ 结构的自引用
				○ 结构体变量的定义和初始化
				○ 结构体内存对齐
				○ 结构体传参
				○ 结构体实现位段(位段的填充&可移植性)

			● 枚举
				○ 枚举类型的定义
				○ 枚举的优点
				○ 枚举的使用

			● 联合
				○ 联合类型的定义
				○ 联合的特点
				○ 联合大小的计算

		――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

		● 结构体

			○ 结构体类型的声明

				结构的基础知识
					结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。

					结构是用来定义一个复杂对象的

					复杂类型
						生活中有一些对象是复杂的，
						比如
							书：书名，作者，出版社，定价，书号......
							学生：名字，年龄，电话，学号......

				结构的声明
					struct tag
					{
						member-list;
					}variable-list;

					struct			关键字
					tag				结构体标签名
					struct tag		结构体类型名
					member-list		成员变量的列表
					variable-list	变量列表

					讲解在
						结构体类型的声明_结构的声明();

				特殊的声明
					在声明结构的时候，可以不完全的声明
					匿名结构体类型创建好后只能使用一次，创建不了变量，因为没有结构体标签名

					讲解在
						结构体类型的声明_特殊的声明();


			○ 结构的自引用

				在结构中包含一个类型为该结构本身的成员是否可以？

				讲解在
					结构的自引用();


			○ 结构体变量的定义和初始化

				讲解在
					结构体变量的定义和初始化();


			○ 结构体内存对齐
				现在我们深入讨论一个问题：计算结构体的大小
				这也是一个特别热门的考点：结构体内存对齐

				结构体的对齐规则
					1. 第一个成员在与结构体变量偏移量为0的地址处
					2. 其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处
					3. 结构体总大小为最大对齐数(每个成员变量都有一个对齐数)的整数倍
					4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，
					   结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍

					对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值

					VS中默认的值为8
					Linux没有默认对齐数的概念

							-----
							|   |
							-----
							|   |
							-----
							|   |
							----- ← 变量s从这开辟空间，并且向下走↓，总共占了12字节
					偏移量0	|   | 成员 char c1
							-----
					偏移量1	|   | (浪费的)
							-----
					偏移量2	|   | (浪费的)
							-----
					偏移量3	|   | (浪费的)
							-----
					偏移量4	|   | 成员 int i
							-----
					偏移量5	|   | 成员 int i
							-----
					偏移量6	|   | 成员 int i
							-----
					偏移量7	|   | 成员 int i
							-----
					偏移量8	|   | 成员 char c2
							-----
							|   | (浪费的)
							-----
							|   | (浪费的)
							-----
							|   | (浪费的)
							-----
							|   |
							-----
					
				为什么存在内存对齐？
					大部分的参考资料都是如是说：

						1. 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；
							某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

						2. 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。
							原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

					总体来说：
						结构体的内存对齐是拿 空间 来换取 时间 的做法。

					在设计结构体的时候，要满足对齐，又要节省空间，应该：
						让占用空间小的成员尽量集中在一起

				修改默认对齐数
					#pragma 预处理指令
					#pragma pack(8)// 设置默认对齐数为8

				百度面试题：
					写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明

					考察：offsetof 宏的实现
					注：这里还没学习宏

				offsetof
					offsetof (type,member)
					<cstdef> （stddef.h）

					offset of
					偏移量 谁

					Return member offset
					This macro with functional form returns the offset value in bytes of member member in the data structure or union type type.
					The value returned is an unsigned integral value of type size_t with the number of bytes between the specified member and the beginning of its structure.

					返回成员偏移量
					此具有函数形式的宏返回数据结构或联合类型类型中成员成员的偏移量值（以字节为单位）。
					返回的值是 size_t 类型的无符号整数值，其字节数介于指定成员及其结构的开头之间。

				讲解在
					结构体内存对齐();
					结构体内存对齐II();
					结构体内存对齐_修改默认对齐数();
					结构体内存对齐_宏offsetof();


			○ 结构体传参

				讲解在
					结构体传参();


			○ 结构体实现位段(位段的填充&可移植性)

				什么是位段
					位段的声明和结构是类似的，有两个不同：
						1. 位段的成员必须是 int，unsigned int，signed int。其实还能有char类型，char属于整形家族。
						2. 位段的成员名后边有一个冒号和一个数字。

				位段的内存分配
					1. 位段的成员必须是 int，unsigned int，signed int。其实还能有char类型，char属于整形家族。
					2. 位段的空间上是按照需要以4个字节(int)或者1个字节(char)的方式来开辟的。
					3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。

				位段的跨平台问题
					1. int 位段被当成有符号数还是无符号数是不确定的。
					2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。
					3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
					4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。

				总结
					跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。

				位段的应用
					网络ip数据包格式

					0                             15 16                            31
					|---------------------------------------------------------------|――
					| 4位	| 4位首	| 8位服务器类型	| 16位总长度						| ↑
					| 版本号	| 部长度	|     (TOS)     | (total length)				| ↑
					|-------------------------------|-------------------------------| ↑
					| 16位标识符						| 3位	| 13位片偏移				| ↑
					| (identifier)					| 标志	| (offset)				| ↑
					|---------------------------------------------------------------| ↑
					| 8位生存时间TTL	| 8位协议		| 16位首部校验和					| 20字节
					| (time to live)| (protocol)	| (checksum)					| ↑
					|---------------------------------------------------------------| ↓
					| 32位源ip地址(source address)									| ↓
					|---------------------------------------------------------------| ↓
					| 32位目的ip地址(destinatin address)								| ↓
					|---------------------------------------------------------------|――
					| 32位选项(若有)													|
					|---------------------------------------------------------------|
					| 数据															|
					|																|
					|																|
					|---------------------------------------------------------------|

				讲解在
					结构体实现位段();
					结构体实现位段II();
*/
/*――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――*/
/*
	数据结构
		数据在内存中存储的结构

		假设存储数据1 2 3 4 5

		线性数据结构
			顺序表：
				[1][2][3][4][5]
				--------------→

			链表：
				[1]
				  K
					K			  [3]
					  K			 J|
						K	   J  |
						  K J	   |
						   [2]	   |
								   ↓
					[5]←----------[4]

				链表里存1的东西叫做 节点，多个节点要串起来，节点该如何设计？
				节点前面存数据，后面存下一个节点的地址，最后一个节点后面存空指针
				节点分成两部分：[ 数据域 | 指针域 ]

		树形
			二叉树
*/
/*――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――*/

#include "define.h"
#include <stddef.h>

void n(int y)
{
	if (y < 0)
	{
		y = y * (-1);
		printf("\n-------- -------- -------- --------");
		int i = 0;
		for (i = 0; i < y; i++)
		{
			printf("\n");
		}
	}
	else
	{
		int i = 0;
		for (i = 0; i < y; i++)
		{
			printf("\n");
		}
	}
}

/**************************************************************************************************************************************************/
/*================================================================================================================================================*/

void 结构体类型的声明_结构的声明()
{
	printf("结构体类型的声明_结构的声明\n");

	struct 书
	{
		char 书名[20];
		int 定价;
		char 书号[12];
	}b4, b5, b6;// 用结构体类型创建变量

	struct 书 b1;// 用结构体类型创建变量
	struct 书 b2;
	struct 书 b3;

	n(1);
}

/*================================================================================================================================================*/

void 结构体类型的声明_特殊的声明()
{
	printf("结构体类型的声明_特殊的声明\n");

	// 匿名结构体类型
	struct 
	{
		int a;
		char b;
		float c;
	}x;

	// 匿名结构体类型
	struct
	{
		int a;
		char b;
		float c;
	}*ps;	// * 匿名结构体类型的指针
			// 用这个指针类型创建了变量ps

	ps = &x;// 在编译器看来，虽然成员一样，但是类型不一样
			// 如果类型不相同，这个结构体的指针里就不能存放x变量的地址
			// 从“*”到“*”的类型不兼容
			// 编译器会把上面的两个声明当成完全不同的两个类型，所以是非法的

	n(1);
}

/*================================================================================================================================================*/

void 结构的自引用()
{
	printf("结构的自引用\n");

	// 行
	struct A
	{
		int i;
		char c;
	};

	// 行
	struct B
	{
		char c;
		struct A sa;
		double d;
	};

	// 这样不行，自己不能包含自己，会套娃，大小无限
	//struct N
	//{
	//	int d;
	//	struct N n;
	//};

	// 结构的自引用，不是包含同类型结构体的变量，而是包含同类型结构体的指针
	struct 节点
	{
		int 数据;
		struct 节点* 下一个;// 为什么是struct 节点*？因为存的下一个节点，类型和它一样。
						   // 如果是指针变量，那大小就是可算的，4或8字节
	};

	n(1);
}

/*================================================================================================================================================*/

void 结构体变量的定义和初始化()
{
	printf("结构体变量的定义和初始化\n");

	struct S
	{
		char c;
		int i;
	}s1, s2;// 声明类型的同时定义变量s1，s2

	struct B
	{
		double d;
		struct S s;
		char c;
	};

	struct S s3, s4;// 定义结构体变量s3，s4
	struct S s5 = { 'x',20 };// 初始化，定义变量的同时赋初值
	struct B b1 = { 3.14,{ 'x',20 } ,'q' };// 结构体包含结构体初始化

	printf("%lf %c %d %c\n", b1.d, b1.s.c, b1.s.i, b1.c);//操作符 . 和 -> ，.针对结构体变量 ->针对结构体指针

	n(1);
}

/*================================================================================================================================================*/

void 结构体内存对齐()
{
	printf("结构体内存对齐\n");

	struct S
	{
		int i;
		char c;
	};

	struct S2
	{
		char c1;
		int i;
		char c2;
	};

	struct S s = { 0 };// 不完全初始化，其余默认初始化为0
	struct S2 s2 = { 0 };

	// 大小不一样，涉及到结构体内存对齐
	printf("%d\n", sizeof(s));
	printf("%d\n", sizeof(s2));

	n(1);
}

/*------------------------------------------------------------------------------------------------------------------------------------------------*/

void 结构体内存对齐II()
{
	printf("结构体内存对齐II\n");

	struct S
	{
		char c1;
		int i;
		char c2;
	};

	struct S4
	{
		double d;
		char c;
		int i;
	};

	struct S5
	{
		char c1;
		struct S4 s4; // s4 占16字节，要如何放？
		double d;
	};

	struct S s = { 0 };
	struct S5 s5 = { 0 };

	printf("%d\n", sizeof(s));
	printf("%d\n", sizeof(s5));			// 32
	printf("%d\n", sizeof(struct S5));	// 32

	/*
		4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，
		   结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍

			偏移量	空间		说明
					-----
					|   |
					----- ← 变量s5从这开辟空间，并且向下走↓，总共占了32字节
				0	|   | 成员 char c1
					-----
				1	|   | (浪费的)
					-----
				2	|   | (浪费的)
					-----
				3	|   | (浪费的)
					-----
				4	|   | (浪费的)
					-----
				5	|   | (浪费的)
					-----
				6	|   | (浪费的)
					-----
				7	|   | (浪费的)
					-----
				8	|   | 成员 struct S4 s4 成员 double d
					-----
				9	|   | 成员 struct S4 s4 成员 double d
					-----
				10	|   | 成员 struct S4 s4 成员 double d
					-----
				11	|   | 成员 struct S4 s4 成员 double d
					-----
				12	|   | 成员 struct S4 s4 成员 double d
					-----
				13	|   | 成员 struct S4 s4 成员 double d
					-----
				14	|   | 成员 struct S4 s4 成员 double d
					-----
				15	|   | 成员 struct S4 s4 成员 double d
					-----
				16	|   | 成员 struct S4 s4 成员 char c
					-----
				17	|   | 成员 struct S4 s4 (浪费的)
					-----
				18	|   | 成员 struct S4 s4 (浪费的)
					-----
				19	|   | 成员 struct S4 s4 (浪费的)
					-----
				20	|   | 成员 struct S4 s4 成员 int i
					-----
				21	|   | 成员 struct S4 s4 成员 int i
					-----
				22	|   | 成员 struct S4 s4 成员 int i
					-----
				23	|   | 成员 struct S4 s4 成员 int i
					-----
				24	|   | 成员 double d
					-----
				25	|   | 成员 double d
					-----
				26	|   | 成员 double d
					-----
				27	|   | 成员 double d
					-----
				28	|   | 成员 double d
					-----
				29	|   | 成员 double d
					-----
				30	|   | 成员 double d
					-----
				31	|   | 成员 double d
					-----
	*/

	n(1);
}

/*================================================================================================================================================*/

void 结构体内存对齐_修改默认对齐数()
{
	printf("结构体内存对齐_修改默认对齐数\n");

#pragma pack(2)// 设置默认对齐数为2
	struct S1
	{
		char c1;
		int i;
		char c2;
	};
#pragma pack()// 这个结构体结束的时候再改回来，留空为默认对齐数

	struct S2
	{
		char c1;
		int i;
		char c2;
	};

	printf("%d\n", sizeof(struct S1));
	printf("%d\n", sizeof(struct S2));

	n(1);
}

/*================================================================================================================================================*/

void 结构体内存对齐_宏offsetof()
{
	printf("结构体内存对齐_宏offsetof\n");

	struct S
	{
		char c1;
		int i;
		char c2;
	};

	printf("%d\n", offsetof(struct S, c1));
	printf("%d\n", offsetof(struct S, i));
	printf("%d\n", offsetof(struct S, c2));

	n(1);
}

/*================================================================================================================================================*/

struct S999// 全局的
{
	int data[1000];// 1000个整形元素的数组
	int num;
};

void print1(struct S999 s)// 结构体传参
{
	printf("%d\n", s.num);
}

void print2(struct S999* ps)// 结构体地址传参
{
	printf("%d\n", ps->num);
}

void 结构体传参()
{
	printf("结构体传参\n");

	struct S999 s = { {1,2,3,4},1000 };

	print1(s);	// 传结构体
	print2(&s);	// 传地址

	/*
		以上print2函数更好
			函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。
			如果传递一个结构体对象的时候，结构体过大，参数压栈的系统开销比较大，会导致性能下降。
	*/

	n(1);
}

/*================================================================================================================================================*/

void 结构体实现位段()
{
	printf("结构体实现位段\n");

	/*
		当没有冒号和数字，这就是一个结构体，_a_b_c_d是成员
			struct A
			{
				int _a ;
				int _b ;
				int _c ;
				int _d ;
			};

		如果成员是int是按照4字节开辟空间
		如果成员是char是按照1字节开辟空间

		4个字节 - 32bit

		位段一定程度上帮我们节省空间
			表示性别有3种
				男
				女
				保密

			如果用二进制来表示
				00 男
				01 女
				10 保密
				11 (剩余的状态)

			2个bit位的空间可以存放4种状态
				00，01，10，11

			当有一些成员的取值没那么大的时候，就按需分配
	*/

	struct A
	{
		// 开辟了4个字节 - 32bit，当前总共开辟了32bit

		int _a : 2;	// _a成员占2个bit位，	还剩30bit
		int _b : 5;	// _b成员占5个bit位，	还剩25bit
		int _c : 10;// _c成员占10个bit位，	还剩15bit

		// 开辟了4个字节 - 32bit，当前总共开辟了64bit

		int _d : 30;// _d成员占30个bit位，延用之前的15bit还是直接使用新开辟的32bit是不确定的，C语言标准没有规定
					// 3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。
	};

	printf("%d\n", sizeof(struct A));// 8个字节

	n(1);
}

/*------------------------------------------------------------------------------------------------------------------------------------------------*/

void 结构体实现位段II()
{
	printf("结构体实现位段II\n");

	/*
		开辟了1个字节 - 8bit，当前总共开辟了8bit

			00000000

			成员a占了左边3个bit位还是右边3个bit位不确定
			这块内存是从 地位到高位 还是 高位到地位 使用的是不确定的
				↓↓↓
				00000000
					 ↑↑↑

			假设a使用
				00000000
					 ↑↑↑

			假设b使用
				00000000
				 ↑↑↑↑↑↑↑
				 ↑↑↑↑

		开辟了1个字节 - 8bit，当前总共开辟了16bit

			00000000 00000000

			假设c浪费了前面1个bit位，使用新开辟的
				00000000 00000000
				 ↑↑↑↑↑↑↑    ↑↑↑↑↑
				 ↑↑↑↑       ↑↑↑↑↑
							↑↑↑↑↑

		开辟了1个字节 - 8bit，当前总共开辟了24bit

			00000000 00000000 00000000

			假设d浪费了前面3个bit位，使用新开辟的
				00000000 00000000 00000000
				 ↑↑↑↑↑↑↑    ↑↑↑↑↑     ↑↑↑↑
				 ↑↑↑↑       ↑↑↑↑↑     ↑↑↑↑
							↑↑↑↑↑     ↑↑↑↑
									  ↑↑↑↑

		赋值
			s.a = 10;
				a只有3个bit位，10的二进制是1010
				那就只能放010
				00000010 00000000 00000000
				 ↑↑↑↑↑↑↑    ↑↑↑↑↑     ↑↑↑↑
				 ↑↑↑↑       ↑↑↑↑↑     ↑↑↑↑
							↑↑↑↑↑     ↑↑↑↑
									  ↑↑↑↑

			s.b = 12;
				12的二进制是1100
				01100010 00000000 00000000
				 ↑↑↑↑↑↑↑    ↑↑↑↑↑     ↑↑↑↑
				 ↑↑↑↑       ↑↑↑↑↑     ↑↑↑↑
							↑↑↑↑↑     ↑↑↑↑
									  ↑↑↑↑

			s.c = 3;
				3的二进制是11，c有5个bit位，要凑够5个bit位
				高位补0，
				00011
				01100010 00000011 00000000
				 ↑↑↑↑↑↑↑    ↑↑↑↑↑     ↑↑↑↑
				 ↑↑↑↑       ↑↑↑↑↑     ↑↑↑↑
							↑↑↑↑↑     ↑↑↑↑
									  ↑↑↑↑

			s.d = 4;
				4的二进制是100，d有4个bit位，要凑够4个bit位
				高位补0，
				0100
				01100010 00000011 00000100
				 ↑↑↑↑↑↑↑    ↑↑↑↑↑     ↑↑↑↑
				 ↑↑↑↑       ↑↑↑↑↑     ↑↑↑↑
							↑↑↑↑↑     ↑↑↑↑
									  ↑↑↑↑

			调试内存窗口&s，转换成16进制
				0110 0010 0000 0011 0000 0100
				   6    2    0    3    0    4
	*/

	struct S
	{
		// 开辟了1个字节 - 8bit，当前总共开辟了8bit

		char a : 3;
		char b : 4;
		char c : 5;
		char d : 4;
	};

	struct S s = { 0 };// 初始化成0

	s.a = 10;
	s.b = 12;
	s.c = 3;
	s.d = 4;

	/*
		当前VS编译器
			1个字节/1个整形 内部数据，先使用低bit位的数据，再使用高bit位的数据，从右向左使用
				高    低
				↓      ↓
				00000000
					   ←

			当一块空间剩余不足下一个成员使用时，剩余的会浪费掉

		这个例子仅仅适配VS编译器
		大小端讨论的是，字节序，大小端字节序
		这里是以一个字节为单位来讨论的

				 有顺序    有顺序
				________ ________
			   ↓        ↓        ↓
			00000000 00000000 00000000

		一个字节内的顺序和大小端没有关系
	*/

	n(-2);
}

/*================================================================================================================================================*/

int main()
{
	结构体类型的声明_结构的声明();

	结构体类型的声明_特殊的声明();

	结构的自引用();

	结构体变量的定义和初始化();

	结构体内存对齐();
	结构体内存对齐II();

	结构体内存对齐_修改默认对齐数();

	结构体内存对齐_宏offsetof();

	结构体传参();

	结构体实现位段();
	结构体实现位段II();

	return 0;
}

/**************************************************************************************************************************************************/
