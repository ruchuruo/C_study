/*
	程序环境和预处理

		本章重点
			1. 程序的翻译环境
			2. 程序的执行环境
			3. 详解：C语言程序的编译+链接
			4. 预定义符号介绍
			5. 预处理指令 #define
			6. 宏和函数的对比
			7. 预处理操作符#和##的介绍
			8. 命令定义
			9. 预处理指令 #include
			10 预处理指令 #undef
			11 条件编译

		――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
		----------------------------------------------------------------

		1. 程序的翻译环境

			在ANSI C的任何一种实现中，存在两个不同的环境
				第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。
				第2种是执行环境，它用于实际执行代码。

		----------------------------------------------------------------

		2. 程序的执行环境

			在ANSI C的任何一种实现中，存在两个不同的环境
				第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。
				第2种是执行环境，它用于实际执行代码。

				test.c →翻译环境→ test.exe →运行环境→ 运行结果
						VS2022

		----------------------------------------------------------------

		3. 详解：C语言程序的编译+链接

			3.1 翻译环境

				程序编译过程

				源文件 → 编译器 → [    ]目标文件 →
				                                ↓
				源文件 → 编译器 → [    ]目标文件 →
				                                ↓
				源文件 → 编译器 → [    ]目标文件 →
				                                ↓
				链接库 → 链接器←←←←←←←←←←←←←←←←←←←
				           ↓
				       可执行程序

				每个 源文件 都是单独处理的

				.obj 目标文件
				.lib 静态库

				编译：
					组成一个程序的每个源文件（.c文件）通过编译过程分别转换成目标代码（.obj文件）(object code)。
				链接：
					每个目标文件由链接器（linker）捆绑在一起，形成一个单一而完整的可执行程序（.exe文件）。

					链接器同时也会引入标准C函数库中任何被该程序所用到的函数，
					而且它可以搜索程序员个人的程序库，将其需要的函数也链接到程序中。


				test.c
				↓
				编译环境(VS2022集成开发环境)
					编译
						编译器cl.exe
							预编译(预处理)
								(*.i)
								(文本操作)
								#include 头文件的包含 (将源文件中以”include”格式包含的文件复制到编译的源文件中)
								#define 定义的符号和宏的替换 (用实际值替换用“#define”定义的字符串。)
								根据“#if”后面的条件决定需要编译的代码。
								删除注释
								......
								(gcc test.c -E)(gcc test.c -E > test.i)
							编译
								(*.s)
								把 C语言代码 转换成 汇编代码
								语法分析
								词法分析
								语义分析
								符号汇总
								(gcc test.i -S)
							汇编
								(*.o)(*.obj)
								(test.o 是elf格式的文件)(test.o 划分成了一个一个的段)(每一个段里存放的数据不同)(readelf命令，一般用于查看ELF格式的文件信息)
								把 汇编代码 转换成 机器指令(二进制指令)
								形成符号表
								(gcc test.s -c)
								(readelf test.o -s)
					链接
						链接器link.exe
							(*.out)(*.exe)
							(.out和.exe也是elf格式)
							把多个 目标文件 和 链接库 进行链接
							合并段表(相同段的数据合并)
							符号表的合并和符号表的重定位
				↓
				test.exe
				↓
				运行环境
				↓
				运行结果


			3.2 编译本身也分为几个阶段

				----------------------------------------------------------------------------------------------------------------------
				|    test.c  |  预编译阶段(*.i)  |  编译(*.s)  |  汇编(生成可重定目标文件*.o)     |  链接                              |
				|            |  预处理指令       |  语法分析   |  形成符号表                      |                                    |
				|            |                   |  词法分析   |  汇编指令->二进制指令--->test.o  |  1. 合并段表                       |
				|            |                   |  语义分析   |  汇编指令->二进制指令--->sum.o   |  2. 符号表的合并和符号表的重定位    |
				|    sum .c  |                   |  符号汇总   |                                 |                                    |
				|--------------------------------------------------------------------------------------------------------------------|
				|    隔离编译，一起链接                                                                                               |
				----------------------------------------------------------------------------------------------------------------------

				合并段表
					[ ] →← [ ]
					[ ] →← [ ]
					[ ] →← [ ]
					[ ] →← [ ]
					[ ] →← [ ]

				形成符号表
					(test.c里Add函数只是声明，没有确切地址)
					test.c    [Add] [0x0000]
					          [main][0x1004]

					sum.c     [Add] [0x1008]

				符号表的合并和符号表的重定位
					(筛选有效地址的符号)
					test.c    [Add] [0x0000] -
					          [main][0x1004]  |
					                          | → [Add] [0x1008]
					sum.c     [Add] [0x1008] -    [main][0x1004]
					(链接好的可执行程序，调用函数，通过地址就能找到函数)


			3.3 运行环境
				
				程序执行的过程

					1. 程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。
					   在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。

					2. 程序的执行便开始。接着便调用main函数。

					3. 开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack）(即前面学的函数栈帧)，存储函数的局部变量和返回地址。
					   程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。

					4. 终止程序。正常终止main函数；也有可能是意外终止。

		----------------------------------------------------------------

		4. 预定义符号介绍
			
			4.1 预定义符号
				__FILE__ 	//进行编译的源文件
				__LINE__ 	//文件当前的行号
				__DATE__ 	//文件被编译的日期
				__TIME__ 	//文件被编译的时间
				__STDC__ 	//如果编译器遵循ANSI C，其值为1，否则未定义

				这些预定义符号都是语言内置的。


			4.2 #define

				4.2.1 #define 定义标识符

					语法：
						#define name stuff

					例如：
						#define MAX 1000
						#define reg register		//为 register这个关键字，创建一个简短的名字
						#define do_forever for(;;)	//用更形象的符号来替换一种实现
						#define CASE break;case		//在写case语句的时候自动把 break写上。

						// 如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。
						#define DEBUG_PRINT printf("file:%s\tline:%d\t \
							date:%s\ttime:%s\n" ,\
							__FILE__,__LINE__ , \
							__DATE__,__TIME__ )

					在define定义标识符的时候，尽量不要在最后加上 ;
					这样容易导致问题。
						
						#define MAX 1000;
						int a = MAX;

						替换过去就成了

						int a = 1000;;

				4.2.2 #define 定义宏

					#define 机制包括了一个规定，允许把参数替换到文本中，
					这种实现通常称为宏（macro）或定义宏（define macro）。

					宏的申明方式：
						#define name( parament-list ) stuff
									  参数列表         内容
									  参数列表 里的 参数 可以替换到 内容 里

						其中的 parament-list 是一个由逗号隔开的符号表，它们可能出现在stuff中。

					注意：
						参数列表的左括号必须与name紧邻。
						如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分。

						例如：
							             ↓↓
							#define SQUARE(x) x * x

					宏的使用方式：
						#define SQUARE(x) x * x

						printf("%d\n", SQUARE(3));

						这个宏接收一个参数x，
						将 SQUARE(3) 置于程序中，
						预处理器就会用下面这个表达式替换上面的表达式：
						3 * 3

						printf("%d\n", 3 * 3);

					警告：
					此时写法的宏有一定的问题：

						#define SQUARE(x) x * x

						printf("%d\n", SQUARE(3 + 1));// 16?

						替换后

						printf("%d\n", 3 + 1 * 3 + 1);// 7

					建议写法
						#define SQUARE(x) ((x) * (x))

					所以用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，
					避免在使用宏时由于参数中的操作符或邻近操作符之间不可预料的相互作用。


				4.2.3 #define 替换规则

					在程序中扩展#define定义符号和宏时，需要涉及几个步骤。
						1. 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。
						2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替换。
						3. 最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。
						   如果是，就重复上述处理过程。

					注意：
						1. 宏参数和#define 定义中可以出现其他#define定义的符号。但是对于宏，不能出现递归。
						2. 当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索。


				4.2.4 #和##

					如何把参数插入到字符串中？

					printf("hello world\n");
					和
					printf("hello" "world\n");
					处理方式一样

					字符串是有自动连接的特点的。

					#的作用
						把一个宏参数变成对应的字符串。

					##的作用
						##可以把位于它两边的符号合成一个符号。
						它允许宏定义从分离的文本片段创建标识符。

						注意：这样的连接必须产生一个合法的标识符。否则其结果就是未定义的。


				4.2.5 带副作用的宏参数

					当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，
					那么你在使用这个宏的时候就可能出现危险，导致不可预测的后果。
					副作用就是表达式求值的时候出现的永久性效果。

					例如：
						x+1;//不带副作用
						x++;//带有副作用

						int a = 1;
						int b = a + 1;// b = 2, a = 1
						int b = ++a;//   b = 2, a = 2
						
						++a有副作用，给b赋值的同时把自己也改变了

					以下 MAX 宏可以证明具有副作用的参数所引起的问题。
						#define MAX(X, Y) ( (X) > (Y) ? (X) : (Y) )


				3.2.6 宏和函数对比

					宏通常被应用于执行简单的运算。
					比如在两个数中找出较大的一个。
						#define MAX(a, b) ((a)>(b)?(a):(b))

					那为什么不用函数来完成这个任务？
					原因有二：
						1. 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。 
						   所以宏比函数在程序的规模和速度方面更胜一筹。
						2. 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。
						   反之这个宏怎可以适用于整形、长整型、浮点型等 可以用于>来比较的类型。宏是类型无关的。
						
					宏的缺点：当然和函数相比宏也有劣势的地方：
						1. 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。
						2. 宏是没法调试的。
						3. 宏由于类型无关，也就不够严谨。
						5. 宏可能会带来运算符优先级的问题，导致程容易出现错。

					宏有时候可以做函数做不到的事情。比如：宏的参数可以出现类型，但是函数做不到。

					宏和函数的一个对比
						--------------------------------------------------------------------------------------------------------------------------------------------------------------------
						|属性             |   #define定义宏                                     |   函数                                                                                    |
						|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
						|代码长度         |   每次使用时，宏代码都会被插入到程序中。              |                                                                                          |
						|                 |   除了非常小的宏之外，程序的长度会大幅度增长。        |   函数代码只出现于一个地方；每次使用这个函数时，都调用那个地方的同一份代码                   |
						|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
						|执行速度         |   更快。                                            |   存在函数的调用和返回的额外开销，所以相对慢一些                                            |
						|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
						|操作符优先级      |  宏参数的求值是在所有周围表达式的上下文环境里，      |                                                                                           |
						|                 |   除非加上括号，                                    |                                                                                           |
						|                 |   否则邻近操作符的优先级可能会产生不可预料的后果，    |                                                                                           |
						|                 |   所以建议宏在书写的时候多些括号。                   |   函数参数只在函数调用的时候求值一次，它的结果值传递给函数。表达式的求值结果更容易预测。      |
						|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
						|带有副作用的参数  |  参数可能被替换到宏体中的多个位置，                  |                                                                                           |
						|                 |  所以带有副作用的参数求值可能会产生不可预料的结果。   |   函数参数只在传参的时候求值一次，结果更容易控制。                                          |
						|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
						|参数类型         |   宏的参数与类型无关，只要对参数的操作是合法的，      |                                                                                           |
						|                 |   它就可以使用于任何参数类型。                       |   函数的参数是与类型有关的，如果参数的类型不同，就需要不同的函数，即使他们执行的任务是不同的。|
						|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
						|调试             |   宏是不方便调试的。                                 |   函数是可以逐语句调试的                                                                  |
						|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
						|递归             |   宏是不能递归的。                                   |   函数是可以递归的                                                                        |
						--------------------------------------------------------------------------------------------------------------------------------------------------------------------

					内联函数(C++)
						inline 结合了 宏 和 函数 的优点


				4.2.7 命名约定

					一般来讲函数的宏的使用语法很相似。所以语言本身没法帮我们区分二者。
					那我们平时的一个习惯是：
						把宏名全部大写
						函数名不要全部大写

			4.3 #undef

				这条指令用于移除一个宏定义。
					#undef NAME
					//如果现存的一个名字需要被重新定义，那么它的旧名字首先要被移除。


			4.4 命令行代码

				许多C 的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。
				例如：当我们根据同一个源文件要编译出不同的一个程序的不同版本的时候，这个特性有点用处。
				（假定某个程序中声明了一个某个长度的数组，如果机器内存有限，我们需要一个很小的数组，
				但是另外一个机器内存大写，我们需要一个数组能够大写。）

					#include <stdio.h>
					int main()
					{
						int array[ARRAY_SIZE];
						int i = 0;
						for (i = 0; i < ARRAY_SIZE; i++)
						{
							array[i] = i;
						}
						for (i = 0; i < ARRAY_SIZE; i++)
						{
							printf("%d ", array[i]);
						}
						printf("\n");
						return 0;
					}

				编译指令：
					//linux 环境演示
					       -D定义 数组大小=10
					            ↓
					gcc test.c -D ARRAY_SIZE=10

				此时打印结果为：0 1 2 3 4 5 6 7 8 9


			4.5 条件编译

				在编译一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。因为我们有条件编译指令。

				例如：
					调试性的代码，删除可惜，保留又碍事，所以我们可以选择性的编译。

				条件为假，预处理阶段 这段代码会被删除
					#ifdef 符号
						// 是否被编译的代码
					#endif 

				常见的条件编译指令：
					1.
						#if 常量表达式
							//...
						#endif
						//常量表达式由预处理器求值。
						如：
						#define __DEBUG__ 1
						#if __DEBUG__
							//..
						#endif

					2.多个分支的条件编译
						#if 常量表达式
							//...
						#elif 常量表达式
							//...
						#else
							//...
						#endif

					3.判断是否被定义
						#if defined(symbol)
						#ifdef symbol
						#if !defined(symbol)
						#ifndef symbol

					4.嵌套指令
						#if defined(OS_UNIX)
							#ifdef OPTION1
								unix_version_option1();
							#endif
							#ifdef OPTION2
								unix_version_option2();
							#endif
						#elif defined(OS_MSDOS)
							#ifdef OPTION2
								msdos_version_option2();
							#endif
						#endif


			3.6 文件包含

				#include 指令可以使另外一个文件被编译。就像它实际出现于 #include 指令的地方一样。

				这种替换的方式很简单：
					预处理器先删除这条指令，并用包含文件的内容替换。
					这样一个源文件被包含10次，那就实际被编译10次。

				3.6.1 头文件被包含的方式

					3.6.1.1 本地文件包含

						#include "filename"

						查找策略：先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标准位置查找头文件。
						如果找不到就提示编译错误。

						Linux环境的标准头文件的路径：
							/usr/include

						VS环境的标准头文件的路径：
							C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\include
							//这是VS2013的默认路径


					3.6.1.2 库文件包含
						
						#include <filename.h>

						查找头文件直接去标准路径下去查找，如果找不到就提示编译错误。

						这样是不是可以说，对于库文件也可以使用 “” 的形式包含？
						答案是肯定的，可以。
						但是这样做查找的效率就低些，当然这样也不容易区分是库文件还是本地文件了。

				3.6.2 嵌套文件包含

					如果出现这样的场景：

									[test.h][test.c]
											J    ↑
										  J      ↑
										J        ↑
									  J          ↑
									J            ↑
								  J              ↑
								J                ↑
							  J                  ↑
							J                    ↑
						[test1.h][test1.c]    [test2.h][test2.c]
								   I         J
									 I     J
									   I J
									[comm.h][comm.c]

					comm.h和comm.c是公共模块。
					test1.h和test1.c使用了公共模块。
					test2.h和test2.c使用了公共模块。
					test.h和test.c使用了test1模块和test2模块。

					这样最终程序中就会出现两份comm.h的内容。这样就造成了文件内容的重复。
					解决办法是条件编译。为了防止头文件被多次重复包含。

					每个头文件的开头写：
						//code1
						#ifndef __TEST_H__
						#define __TEST_H__
						//头文件的内容
						#endif //__TEST_H__

					或者
						//code2
						#pragma once

					就可以避免头文件的重复引入。


		5. 其他预处理指令
			line
				#line n filename 指定行号

			error
				#error 让预处理（编译）产生错误 直接中断编译
			......


			演示&讲解
				预定义符号介绍_预定义符号();
				预定义符号介绍_预定义符号_写日志();
				预定义符号介绍_井define_井和井井_参数插入到字符串中();
				预定义符号介绍_井define_井和井井_位于它两边的符号合成一个符号();
				预定义符号介绍_井define_带副作用的宏参数();
				预定义符号介绍_井define_宏和函数对比();
				预定义符号介绍_井undef();
				预定义符号介绍_条件编译();
				预定义符号介绍_条件编译_常见的条件编译指令();

		----------------------------------------------------------------

		5. 预处理指令 #define

		----------------------------------------------------------------
		6. 宏和函数的对比
		----------------------------------------------------------------
		7. 预处理操作符#和##的介绍
		----------------------------------------------------------------
		8. 命令定义
		----------------------------------------------------------------
		9. 预处理指令 #include
		----------------------------------------------------------------
		10 预处理指令 #undef
		----------------------------------------------------------------
		11 条件编译
		----------------------------------------------------------------
		――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
*/
/*
		――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

		资料推荐

			《程序员的自我修养》

			简明 VIM 练级攻略
			https://coolshell.cn/articles/5426.html

			给程序员的VIM速查卡
			https://coolshell.cn/articles/5479.html
*/

#include "define.h"

void n2(int 换行次数, char* 换行符号, int 符号个数)
{
	int i = 0;

	if (换行符号 != NULL && 符号个数 > 0)
	{
		printf("\n");
		for (i = 0; i < 符号个数; i++)
		{
			printf("%s", 换行符号);
		}
	}

	for (i = 0; i < 换行次数; i++)
	{
		printf("\n");
	}
}

int 判断文件是否存在(char* 文件路径)
{
	FILE* pfff = fopen(文件路径, "r");

	if (pfff == NULL)
	{
		return 0;
	}

	fclose(pfff);
	pfff = NULL;

	return 1;
}

/**************************************************************************************************************************************************/
/*================================================================================================================================================*/

void 预定义符号介绍_预定义符号()
{
	printf("预定义符号介绍_预定义符号\n");

	printf("file:%s\nline:%d\ndata:%s\ntime:%s\n", __FILE__, __LINE__, __DATE__, __TIME__);
	printf("%s\n", __FUNCTION__);// 函数名

	n2(2, "-------- ", 4);
}

/*================================================================================================================================================*/

void 预定义符号介绍_预定义符号_写日志()
{
	printf("预定义符号介绍_预定义符号_写日志\n");

	if ((判断文件是否存在("..\\测试文件操作\\文件9-预定义符号介绍_预定义符号_写日志.txt")) == 0)
	{
		printf("文件可能不存在\n");
		return;
	}

	
	FILE* pf = fopen("..\\测试文件操作\\文件9-预定义符号介绍_预定义符号_写日志.txt", "a+");
	if (pf == NULL)
	{
		perror("fopen");
		return;
	}

	int i = 0;
	for (i = 0; i < 10; i++)
	{
		fprintf(pf, "file:%s line:%d data:%s time:%s i:%d\n", __FILE__, __LINE__, __DATE__, __TIME__, i);
	}


	fclose(pf);
	pf = NULL;

	n2(2, "-------- ", 4);
}

/*================================================================================================================================================*/

// 错误写法
//#define 打印(x) printf("变量" x "是%d\n", x);

#define 宏_打印(x) printf("变量" #x "是%d\n", x);

#define 宏修改_打印(x, 格式) printf("变量" #x "是" 格式 "\n", x);

void 打印(int x)
{
	////     此处没法改变
	////          ↓
	//printf("变量x是%d\n", x);
}

void 预定义符号介绍_井define_井和井井_参数插入到字符串中()
{
	printf("预定义符号介绍_井define_井和井井_参数插入到字符串中\n");

	printf("hello world\n");
	printf("hello " "world\n");

	// 希望打印：变量a是10
	int a = 10;

	// 希望打印：变量b是20
	int b = 20;

	// 希望打印：变量c是30
	int c = 30;

	// 如果写成函数
	打印(a);
	打印(b);
	打印(c);

	// 宏
	宏_打印(a);
	宏_打印(b);
	宏_打印(c);
	// printf("变量" #x "是%d\n", x);
	// 替换成 参数所对应的字符串
	// printf("变量" "a" "是%d\n", a);

	// 宏 修改
	float f = 5.5f;
	宏修改_打印(f, "%f");
	// printf("变量" #x "是" 格式 "\n", x);
	// 替换成 
	// printf("变量" "f" "是" "%f" "\n", f);


	n2(2, "-------- ", 4);
}

/*================================================================================================================================================*/

#define CAT(X, Y) X##Y

void 预定义符号介绍_井define_井和井井_位于它两边的符号合成一个符号()
{
	printf("预定义符号介绍_井define_井和井井_位于它两边的符号合成一个符号\n");

	int class101 = 100;
	printf("%d\n", CAT(class, 101));
	// ↓
	// printf("%d\n", class##101);
	// ↓
	// printf("%d\n", class101);

	n2(2, "-------- ", 4);
}

/*================================================================================================================================================*/

#define MAX(X, Y) ( (X) > (Y) ? (X) : (Y) )

void 预定义符号介绍_井define_带副作用的宏参数()
{
	printf("预定义符号介绍_井define_带副作用的宏参数\n");

	int a = 5;
	int b = 8;
	int m = MAX(a++, b++);
	// ↓替换成
	//  m = ( (a++) > (b++) ? (a++) : (b++) );
	// ↓开始计算
	// m = ( (5) > (8) ? (a++) : (b++) );
	// ↓后置++生效，b赋值给m
	// m = ( (6) > (9) ? (a++) : (9) );
	// ↓后置++生效，b = 10
	printf("a=%d b=%d m=%d\n", a, b, m);

	n2(2, "-------- ", 4);
}

/*================================================================================================================================================*/

//              个数, 类型
#define MALLOC( NUM, TYPE) (TYPE*)malloc(( NUM ) * sizeof( TYPE ))

void 预定义符号介绍_井define_宏和函数对比()
{
	printf("预定义符号介绍_井define_宏和函数对比\n");

	// malloc(10 * sizeof(int));// 麻烦
	// malloc(10, int);//          这样方便，但是函数不支持。可以传值传变量，不能传类型

	// 宏
	int* p = MALLOC(10, int);
	// ↓替换后
	// * p = (int*)malloc((10) * sizeof(int));

	// !!!!!!!!! 访问冲突 !!!!!!!!!
	//free(p);
	//p = NULL;
	// !!!!!!!!! 访问冲突 !!!!!!!!!

	n2(2, "-------- ", 4);
}

/*================================================================================================================================================*/

#define M 100

void 预定义符号介绍_井undef()
{
	printf("预定义符号介绍_井undef\n");

	int a = M;

#undef M

	//printf("%d\n", M);// 未定义标识符"M"

	n2(2, "-------- ", 4);
}

/*================================================================================================================================================*/

//#define PRINT// 定义这个符号后 条件编译 中的代码就会被编译

void 预定义符号介绍_条件编译()
{
	printf("预定义符号介绍_条件编译\n");

#ifdef PRINT // 如果符号 PRINT 被定义了就会编译以下语句
	printf("hehe\n");
#endif // PRINT

	n2(2, "-------- ", 4);
}

/*================================================================================================================================================*/

void 预定义符号介绍_条件编译_常见的条件编译指令()
{
	printf("预定义符号介绍_条件编译_常见的条件编译指令\n");

	// 1.
#if 1// 常量表达式 1 为真
	printf("hehe\n");
#endif // 1

#if 0// 常量表达式 0 为假
	printf("假\n");
#endif // 0



	// 2.多个分支的条件编译
#if 1 == 1
	printf("1==1\n");
#elif 1 == 2
	printf("1==2\n");
#else
	printf("else\n");
#endif 



	// 3.判断是否被定义
#ifdef TEST // 如果符号 TEST 被定义了就会编译以下语句
	printf("符号被定义了就会编译\n");
#endif 

	// 另一种方式
#if defined(TEST)
	printf("符号被定义了就会编译\n");
#endif


	// 如果符号不定义，就编译
#ifndef TEST2
	printf("如果符号不定义，就编译\n");
#endif // !TEST2

	// 另一种方式
#if !defined(TEST2)
	printf("如果符号不定义，就编译\n");
#endif



	// 4.嵌套指令
//#if defined(OS_UNIX)// 如果是 UNIX 操作系统就编译
//#ifdef OPTION1// 嵌套的
//		unix_version_option1();
//#endif
//#ifdef OPTION2
//	unix_version_option2();
//#endif
//#elif defined(OS_MSDOS)// 如果是 Windows 操作系统就编译
//#ifdef OPTION2// 嵌套的
//		msdos_version_option2();
//#endif
//#endif


	n2(2, "-------- ", 4);
}

/*================================================================================================================================================*/

int main()
{
	预定义符号介绍_预定义符号();
	预定义符号介绍_预定义符号_写日志();
	预定义符号介绍_井define_井和井井_参数插入到字符串中();
	预定义符号介绍_井define_井和井井_位于它两边的符号合成一个符号();
	预定义符号介绍_井define_带副作用的宏参数();
	预定义符号介绍_井define_宏和函数对比();// !!!!!!!!! 访问冲突 !!!!!!!!!
	预定义符号介绍_井undef();
	预定义符号介绍_条件编译();
	预定义符号介绍_条件编译_常见的条件编译指令();

	return 0;
}

/*================================================================================================================================================*/
/**************************************************************************************************************************************************/